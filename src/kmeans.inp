function bundle set_bundle_and_get_defaults (const list xlist,
                                             bundle opts[null])
    /* Compile self bundle by merging eventual information
    from 'opts' bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(xlist)
    self = opts + self          # override defaults

    return self
end function


function bundle default_values (const list xlist)
    /* Set default values. */

    bundle self = null
    scalar self.error = FALSE
    scalar self.verbose = 1
    string self.initializer = "random"
    scalar self.n_init = 10
    scalar self.max_iter = 300
    scalar self.tolerance = 1e-4
    string self.algorithm = "full"
    string self.distance_type = "euclidean"

    return self
end function


function series initialize_clusters (const bundle self)
    /* Randomly assign observations to some initial cluster.
    return: series, Randomly assign 1 to n_cluster ID for each observation. */

    if self.initializer == "random"
        return mrandgen(i, 1, self.n_clusters, $nobs, 1)
    else
        funcerr "Initializer is not supported."
    endif

    return x
end function


function bundle kmeans (const list xlist "Features",
                        const int n_clusters[2::2] "No. of clusters",
                        bundle opts[null] "Parameter bundle")
    /* Main public function. */

    if !exists(opts)
        bundle opts = null
    endif

    # TODO: Inform on how many obs got dropped
    smpl xlist --no-missing

    bundle self = set_bundle_and_get_defaults(xlist, opts)
    strings self.names_xlist = varnames(xlist)
    scalar self.n_clusters = n_clusters

    matrix features = {xlist}

    matrix cluster_id = initialize_clusters(self)
    #print xlist self.cluster_id -o

    matrix centroids = centroids(features, cluster_id)

    # Compute distances
    matrix dist = distances(features, cluster_id, centroids, self.distance_type)
    dist


    # Re-assign clusters to shortest distance

    return self
end function

function matrix distance_euclidean (const matrix features,
                                    const matrix cluster_id,
                                    const matrix centroids)
    /* Compute the euclidean distance
    return: type, description */

    scalar n_clusters = max(cluster_id)
    matrix m = cluster_id ~ features
    matrix new_cluster_id

    loop i=1..n_clusters
        matrix mask = (m[,1] .= $i)                  # select obs. from i-th cluster

        matrix dist = mshape(0, sum(mask), n_clusters) # store distances

        loop j=1..n_clusters        # compute distances for each centroid
            z = selifr(m[,2:], mask) .- centroids[j, 2:] # deviations from centroids

            # Scaled by the number of obs. in the i-th cluster
            dist[,j] = sumr(z.^2) .* 1/sum(mask)
        endloop

        new_cluster_id |= iminr(dist)                   # updated cluster_id
    endloop

    # TODO: Currently this function does more than initially thought of...

    return new_cluster_id
end function


function matrix distances (const matrix features,
                           const matrix cluster_id,
                           const matrix centroids,
                           const string distance_type)
    /* Call function for computing distances between multi-dimensional points.
    return: type, description */

    if distance_type == "euclidean"
        matrix dist = distance_euclidean(features, cluster_id, centroids)
    else
        funcerr(sprintf("Distance type '%s' not supported.", distance_type))
    endif

    return dist
end function


function matrix centroids (const matrix features,
                           const matrix cluster_id)
    /* Compute centroids (means) for each cluster.
    return: "n_clusters by 1+cols(features)" matrix, The i-th row corresponds to the i-th cluster; each column refers to the centroid (mean) value for each respective feature. */

    matrix m = cluster_id ~ features
    scalar n_clusters = max(cluster_id)
    matrix centroids = mshape(NA, n_clusters, cols(features))

    loop i=1..n_clusters
        matrix mask = (m[,1] .= $i)
        centroids[i,] = meanc(selifr(m[,2:], mask))
    endloop

    centroids = seq(1, n_clusters)' ~ centroids

    return centroids
end function



















